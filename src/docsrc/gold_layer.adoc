= Gold layer

The Gold layer represents the final stage in the data pipeline, where the data is refined and optimized for business intelligence and analytics,
separated into facts and dimensions.
For this project, the star schema model is sufficient as there are only a couple of product and customer _dimensions_ surrounding the sales orders _facts_.

First step on how to determine how to build our gold data model is to examine the silver data model and add some labels
to group things logically.

[plantuml,silver_into_categories,png]
----
@startuml

package CRM <<Rectangle>> {
    map crm_sales_details {
        cst_id =>
        prd_key =>
		**>** => **Sales**
    }
    map crm_cust_info {
        cst_id =>
        cst_key =>
		**>** => **Customer**
    }
    map crm_prd_inf {
        prd_key =>
		**>** => **Product**
    }
    crm_sales_details::cst_id --> crm_cust_info::cst_id
    crm_sales_details::prd_key --> crm_prd_inf::prd_key
}

package ERP <<Rectangle>> {
    map erp_cust_az12 {
        cid =>
		**>** => **Customer**
    }
    map erp_loc_a101 {
        cid =>
		**>** => **Customer**
    }
    map erp_px_cat_g1v2 {
        id =>
		**>** => **Product**
    }
    erp_cust_az12::cid --> crm_cust_info::cst_key
    erp_loc_a101::cid --> crm_cust_info::cst_key
    erp_px_cat_g1v2::prd_key --> crm_prd_inf::prd_key
}

@enduml
----

Referring back to the xref:architecture.adoc#_specifications[], we see that rather than loading data,
we'll be creating views into the cleaned silver tables, views that might aggregate and integrate information.

Another thing to add to the views are surrogate keys to use as the primary keys.
TIL that these are exposed in the fact view SELECTs, while it's fact view JOINs that create
the links between the relevant columns gold views (rather than using those columns as foreign keys).
Only after JOINing the fact table are the foreign keys resolved.
That's why it seemed that the surrogates could be sorted however you want. (I think.)

To verify the joins (foreign key integrity) execute joins on the keys and see if any keys are NULL:

```
SELECT COUNT(*) FROM gold.fact_sales f
LEFT JOIN gold.customers c ON f.customer_key = c.customer_key
LEFT JOIN gold.products c ON f.product_key = c.product_key
WHERE p.product_key IS NULL OR c.customer_key IS NULL;
```

After coding the gold layer, we end up with this data model of the star schema:

[plantuml,gold_star,png]
----
@startuml

left to right direction

package gold <<Rectangle>> {

    map gold.dim_customers {
        customer_key => PK
        customer_id =>
        first_name =>
        last_name =>
        country =>
        marital_status =>
        gender =>
        birth_date =>
        create_date =>
    }

    map gold.facts_sales {
        order_number =>
        product_key => FK
        customer_key => FK
        order_date =>
        shipping_date =>
        due_date =>
        sales_amount =>
        quantity =>
        price =>
    }

    map gold.dim_products {
        product_key => PK
        product_id =>
        product_number =>
        product_name =>
        category_id =>
        category =>
        subcategory =>
        maintenance =>
        cost =>
        product_line =>
        start_date =>
    }
}

gold.facts_sales::customer_key }o--|| gold.dim_customers::customer_key
gold.facts_sales::product_key }o--|| gold.dim_products::product_key

@enduml
----
